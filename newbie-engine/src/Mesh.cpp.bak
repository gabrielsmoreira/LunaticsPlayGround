#include "BZK_ParsingTools.h"
#include "Mesh.h"
#include "Graphics.h"
#include "BZK_List.h"

Mesh::Mesh()
{
    iSize.x = iSize.y = iSize.z = 1;
    iPosition.x = iPosition.y = iPosition.z = 0;
    iVel.x = iVel.y =iVel.z = 0;
    //   dMassSetZero(&iMass);
    iM = 1;
    data = new BodyData();
    data->setName("Ground");
    Mat = new Material();
    setColor(Mat->Ka,0.0,0.0,0.0);
    setColor(Mat->Kd,0.0,0.0,0.0);
    setColor(Mat->Ks,1.0,1.0,1.0);
}


Mesh::Mesh(std::string filepath)
{
    iSize.x = iSize.y = iSize.z = 1;
    iPosition.x = iPosition.y = iPosition.z = 0;
    iVel.x = iVel.y =iVel.z = 0;
    //   dMassSetZero(&iMass);
    iM = 1;

    Mat = new Material();
    setColor(Mat->Ka,0.0,0.0,0.0);
    setColor(Mat->Kd,0.0,0.0,0.0);
    setColor(Mat->Ks,1.0,1.0,1.0);

    Datafile.clear();
    Datafile.open(filepath.c_str());
    BZK_List  <vec3d> vList;
    BZK_List <TexCoord2> tList;

    numVecs = 0;
    numTexs = 0;

    while (!Datafile.eof())
    {
        std::string  Echo=BZK_ParsingTools::GetNextToken(&Datafile);

        if (Echo == "v:")
        {
            vec3d v;
            v.x = BZK_ParsingTools::GetNumber(BZK_ParsingTools::GetNextToken(&Datafile));
            v.y = BZK_ParsingTools::GetNumber(BZK_ParsingTools::GetNextToken(&Datafile));
            v.z = BZK_ParsingTools::GetNumber(BZK_ParsingTools::GetNextToken(&Datafile));
            vList.Add(v);
            numVecs++;
        }

        if (Echo == "tex:")
        {
            texture = new TexturePCX(BZK_ParsingTools::GetNextToken(&Datafile).c_str());
        }

        if (Echo == "t:")
        {
            TexCoord2 coord;
            coord.u = BZK_ParsingTools::GetNumber(BZK_ParsingTools::GetNextToken(&Datafile));
            coord.v = BZK_ParsingTools::GetNumber(BZK_ParsingTools::GetNextToken(&Datafile));

            tList.Add(coord);
            numTexs++;
        }

    }

    std::cout << numVecs;
    vecs = new vec3d[numVecs];
    numIndexs = numVecs;
    indexs = new dTriIndex[numIndexs];


    for (int i =0; i < vList.TotalItems(); i++)
    {
        vecs[i] = vList[i];
        indexs[i] = i;
    }

    if (numTexs > 0)
    {
        texCoord = new TexCoord2[numTexs];

        for (int i=0; i<tList.TotalItems(); i++)
        {
            texCoord[i] = tList[i];
        }
    }

    Datafile.clear();

    vbo = new VertexBufferObject();
    vbo->glMode = GL_TRIANGLES;

    vbo->setVertices(vecs,numVecs);
    vbo->setIndexs(indexs,numIndexs);

    if (numTexs > 0)
    {
        vbo->setTexCoords(texCoord,numTexs);
    }


}
void Mesh::MakeBody(dWorldID world)
{
    iBody = dBodyCreate(world);
    dBodySetPosition(iBody,iPosition.x,iPosition.y,iPosition.z);
    dBodySetLinearVel(iBody,iVel.x,iVel.y,iVel.z);
    dBodySetMass(iBody,&iMass);
    disabledSteps = 0;

}

void Mesh::MakeGeom(dSpaceID space)
{

    triData = dGeomTriMeshDataCreate();
    //Physic's Data

    dGeomTriMeshDataBuildSimple(triData, (dReal*)data, numVecs,(dTriIndex*)indexs, numIndexs);
    dGeomTriMeshDataBuildSingle(triData, vecs, 3 * sizeof(float), numVecs, indexs, numIndexs, 3 * sizeof(dTriIndex));
    iGeom = dCreateTriMesh(space, triData,0,0,0);
    dGeomSetPosition(iGeom,iPosition.x,iPosition.y,iPosition.z);
}

void Mesh::Draw()
{
    glPushMatrix();
    glMatrixMode(GL_MODELVIEW);

    glTranslatef(iPosition.x,iPosition.y,iPosition.z);
    if (Mat != NULL)
    {
        Mat->Build();

    }
    //Draw Here
    if (texCoord > 0)
    {
        texture->begin();
    }

  

    vbo->draw();

   


    if (texCoord > 0)
    {
        texture->end();
    }
    glPopMatrix();

}

void Mesh::Update()
{
    const dReal *p = dGeomGetPosition(iGeom);
    iPosition.x = p[0];
    iPosition.y = p[1];
    iPosition.z = p[2];
};

Mesh::~Mesh()
{
}
