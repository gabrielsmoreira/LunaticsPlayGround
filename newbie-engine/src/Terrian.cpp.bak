#ifdef WIN32
#include <windows.h>
#endif
#include "Terrian.h"
#include <stdlib.h>
#include <GL/glew.h>
#include <GL/gl.h>
#include "vec3d.h"
#include "Graphics.h"
#include <math.h>
#include <stdio.h>
#include <SDL/SDL.h>
#include "sdlfunc.h"

#include <cassert>
#include <cstdlib>
#include <ctime>


Terrain::Terrain(unsigned int width, unsigned int height, float scale) {

	w = width + 1;
	h = height + 1;

	numIndexs = (height * width * 6);
	numVecs = (height * width * 4);
	vecs = new vec3d[numVecs];
	texCoord = new TexCoord2[numIndexs];
	indexs = new dTriIndex[numIndexs];


	//  texture = new TexturePCX("storage//textures//ground.bmp");
	//   texture->bind();

	for (int y = 0; y < h; y++)
		for (int x = 0; x < w; x++) {


			int offset = w * y + x;

			vecs[offset].x = (x * scale);
			vecs[offset].y = (y * scale);
			vecs[offset].z = 0.0f;
		}


		int nIndex = 0;


		for (int y = 0; y < h - 1; y++)
			for (int x = 0; x < w - 1; x++) {
				//a
				int a = w * y + x;
				//b
				int b = w * y + (x + 1);
				//c
				int c = w * (y + 1)+(x + 1);
				//d
				int d = w * (y + 1) + x;

				int flx = x * (1 / width);
				int fly = y * (1 / width);

				//Triangulo 1
				indexs[nIndex] = a;

				texCoord[nIndex].u = flx;
				texCoord[nIndex].v = fly;
				nIndex++;

				indexs[nIndex] = b;

				texCoord[nIndex].u = flx;
				texCoord[nIndex].v = 0;
				nIndex++;

				indexs[nIndex] = c;

				texCoord[nIndex].u = 0;
				texCoord[nIndex].v = 0;
				nIndex++;

				//Triangulo 2
				indexs[nIndex] = c;
				texCoord[nIndex].u = 0;
				texCoord[nIndex].v = 0;
				nIndex++;

				indexs[nIndex] = d;
				texCoord[nIndex].u = 0;
				texCoord[nIndex].v = fly;
				nIndex++;

				indexs[nIndex] = a;

				texCoord[nIndex].u = flx;
				texCoord[nIndex].v = fly;
				nIndex++;

			}

			iPosition.x = -(width * scale) / 2.0f;
			iPosition.y = -(height * scale) / 2.0f;
			iPosition.z = 0.0;

			vbo = new VertexBufferObject();
			vbo->glMode = GL_LINES;

			vbo->setVertices(vecs, numVecs);
			vbo->setIndexs(indexs, numIndexs);
			vbo->setTexCoords(texCoord, numIndexs);
			data = new BodyData();
			data->setName("Terrian");


}

void Terrain::MakeGeom(dSpaceID space) {

	// triData = dGeomTriMeshDataCreate();
	//Physic's Data

	//dGeomTriMeshDataBuildSimple(triData, (dReal*)data, numVecs,(dTriIndex*)indexs, numIndexs);
	//dGeomTriMeshDataBuildSingle(triData, vecs, 3 * sizeof(float), numVecs, indexs, numIndexs, 3 * sizeof(dTriIndex));
	//iGeom = dCreateTriMesh(space, triData,0,0,0);
	//dGeomSetPosition(iGeom,iPosition.x,iPosition.y,iPosition.z);


	printf("Terreno Criado\n");
}

void Terrain::Draw() {


	float Ka[] = {0.0,1.0,0.0,1.0};
	float Kd[] = {0.0,1.0,0.0,1.0};
	float Ks[] = {0.7,0.7,0.7,1.0};
	float Sh[] = {10.0};

	glColor3f(0.0, 1.0, 0.0);
	glMaterialfv(GL_FRONT_AND_BACK,GL_AMBIENT,Ka);
	glMaterialfv(GL_FRONT_AND_BACK,GL_DIFFUSE,Kd);
	glMaterialfv(GL_FRONT_AND_BACK,GL_SPECULAR,Ks);

	glMaterialfv(GL_FRONT_AND_BACK,GL_SHININESS,Sh);

	glPushMatrix();
	glMatrixMode(GL_MODELVIEW);

	glTranslatef(iPosition.x, iPosition.y, iPosition.z);

	//Draw Here
	//texture->begin();
	glNormal3f(0.0,0.0,1.0);

	vbo->draw();


	glPopMatrix();
}
